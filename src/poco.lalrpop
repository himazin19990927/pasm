use crate::{token::*, lit::*, register::*, mnemonic::*};

grammar;

pub File: Vec<Instruction> = {
    <Instruction*>
}

pub Instruction: Instruction = {
    "LD" <dst: Register> ","  <src: Parenthesized> => Instruction::R(
        InstructionR {
            funct: Funct::LD,
            dst: dst,
            src: src,
        }
    ),
    "LDI" <dst: Register> "," "#" <imm: "Lit">  => Instruction::from(
        InstructionI {
            opcode: Opcode::LDI,
            dst: dst,
            immediate: imm,
        }
    ),
    "ST" <src: Register> "," <dst: Parenthesized> => Instruction::from(
        InstructionR {
            funct: Funct::ST,
            dst: dst,
            src: src,
        }
    ),
    "ADD" <dst: Register> "," <src: Register> => Instruction::from(
        InstructionR {
            funct: Funct::ADD,
            dst: dst,
            src: src,
        }
    ),
    "ADDI" <dst: Register> "," "#" <imm: "Lit"> => Instruction::from(
        InstructionI {
            opcode: Opcode::ADDI,
            dst: dst,
            immediate: imm,
        }
    ),
};

pub Register: Register = {
    "R0" => Register::R0,
    "R1" => Register::R1,
    "R2" => Register::R2,
    "R3" => Register::R3,
    "R4" => Register::R4,
    "R5" => Register::R5,
    "R6" => Register::R6,
    "R7" => Register::R7,
};

Parenthesized: Register = {
    "(" <Register> ")",
};

extern {
    type Location = ();
    type Error = ();

    enum Token{
        "Lit" => Token::Lit(<Lit>),
        "LD" => Token::LD,
        "LDI" => Token::LDI,
        "ST" => Token::ST,
        "ADD" => Token::ADD,
        "ADDI" => Token::ADDI,

        "R0" => Token::R0,
        "R1" => Token::R1,
        "R2" => Token::R2,
        "R3" => Token::R3,
        "R4" => Token::R4,
        "R5" => Token::R5,
        "R6" => Token::R6,
        "R7" => Token::R7,

        "," => Token::Comma,
        "#" => Token::Sharp,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}