use std::str::FromStr;
use crate::{token::*, register::*, mnemonic::*};

grammar;

pub File: Vec<Item> = {
    <Item*>
}

pub Item: Item = {
    ":" <label: "Ident"> => Item::Label(label),
    <mnemonic: Mnemonic> => Item::Mnemonic(mnemonic),
}

Mnemonic: Mnemonic = {
    "LD" <dst: Register> ","  <src: Parenthesized> => Mnemonic::instr_r(Funct::LD, dst, src),
    "LDI" <dst: Register> "," "#" <imm:Immediate>  => Mnemonic::instr_i(Opcode::LDI, dst, imm),
    "ST" <src: Register> "," <dst: Parenthesized> => Mnemonic::instr_r(Funct::ST, dst, src),
    "ADD" <dst: Register> "," <src: Register> => Mnemonic::instr_r(Funct::ADD, dst, src),
    "ADDI" <dst: Register> "," "#" <imm: Immediate> => Mnemonic::instr_i(Opcode::ADDI, dst, imm),
};

pub Register: Register = {
    "R0" => Register::R0,
    "R1" => Register::R1,
    "R2" => Register::R2,
    "R3" => Register::R3,
    "R4" => Register::R4,
    "R5" => Register::R5,
    "R6" => Register::R6,
    "R7" => Register::R7,
};

Parenthesized: Register = {
    "(" <Register> ")",
};

Immediate: i8 = {
    "-" <imm: "Num"> => -i8::from_str(imm.as_str()).unwrap(),
    <imm: "Num"> => i8::from_str(imm.as_str()).unwrap(),
}

extern {
    type Location = ();
    type Error = ();

    enum Token{
        "Num" => Token::Num(<String>),
        "Ident" => Token::Ident(<String>),
        "LD" => Token::LD,
        "LDI" => Token::LDI,
        "ST" => Token::ST,
        "ADD" => Token::ADD,
        "ADDI" => Token::ADDI,

        "R0" => Token::R0,
        "R1" => Token::R1,
        "R2" => Token::R2,
        "R3" => Token::R3,
        "R4" => Token::R4,
        "R5" => Token::R5,
        "R6" => Token::R6,
        "R7" => Token::R7,

        "," => Token::Comma,
        "#" => Token::Sharp,
        "-" => Token::Minus,
        ":" => Token::Colon,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
    }
}